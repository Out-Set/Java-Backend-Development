Pros of listeners: Publishers and the listeners are loosely coupled also no code dependency there.

Order your listeners:
=====================
By-default: ordering through alphabatic order
@Order(1...) // 1-highest priority
@EventListener
public void emailListener(TransactionFailureEvent event) {
    System.out.println("Sending an email with body \n"
            + "Hi "+event.getName()+", transaction failed for the amount: "+event.getAmount());
}

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Hear multiple events with one listener:
=======================================
@EventListener(classes = {TransactionFailureEvent.class, XYZEvent.class})
public void emailListener() {
    System.out.println("Sending an email...");
}
In this case case you will have the event object.

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Spring build-in events:
=======================

AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(AppConfig.class);
        context.start();
	@Override
	public void start() {
		getLifecycleProcessor().start();
		publishEvent(new ContextStartedEvent(this));
	}

	context.stop();
	@Override
	public void stop() {
		getLifecycleProcessor().stop();
		publishEvent(new ContextStoppedEvent(this));
	}
	
@Component
public class ApplicationContextListeners {

    @EventListener
    public void onContextRefreshedEvent(ContextRefreshedEvent event) {
        System.out.println("application initialized or refreshed... ");
        System.out.println(event);
    }

    @EventListener
    public void onContextStartedEvent(ContextStartedEvent event) {
        System.out.println("application initialized with start()... ");
        System.out.println(event);
    }

    @EventListener
    public void onContextStoppedEvent(ContextStoppedEvent event) {
        System.out.println("application stopped with stop()... ");
        System.out.println(event);
    }

    @EventListener
    public void onContextClosedEvent(ContextClosedEvent event) {
        System.out.println("application closed with close()... ");
        System.out.println(event);
    }
}
    
application initialized or refreshed... 
org.springframework.context.event.ContextRefreshedEvent[source=org.springframework.context.annotation.AnnotationConfigApplicationContext@246b179d, started on Wed Nov 26 00:46:12 IST 2025]
application initialized with start()... 
org.springframework.context.event.ContextStartedEvent[source=org.springframework.context.annotation.AnnotationConfigApplicationContext@246b179d, started on Wed Nov 26 00:46:12 IST 2025]
application stopped with stop()... 
org.springframework.context.event.ContextStoppedEvent[source=org.springframework.context.annotation.AnnotationConfigApplicationContext@246b179d, started on Wed Nov 26 00:46:12 IST 2025]
application closed with close()... 
org.springframework.context.event.ContextClosedEvent[source=org.springframework.context.annotation.AnnotationConfigApplicationContext@246b179d, started on Wed Nov 26 00:46:12 IST 2025]

Note:
=====
The events: ContextRefreshedEvent, ContextStartedEvent, ContextStoppedEvent and ContextClosedEvent are published by the ConfigurableApplicationContext.class

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Async listener setup:
=====================
bean: applicationEventMulticaster

ApplicationEventMulticaster (I)
        |
        |
        |
SimpleApplicationEventMulticaster (C)
  |
  -->taskExecutor -->SimpleAsyncTaskExecutor()
  
Below is the confirued bean:
----------------------------
@Configuration
@ComponentScan("com.savan")
public class AppConfig {

    @Bean("applicationEventMulticaster")
    public ApplicationEventMulticaster makingAsync() {
        SimpleApplicationEventMulticaster applicationEventMulticaster = new SimpleApplicationEventMulticaster();
        applicationEventMulticaster.setTaskExecutor(new SimpleAsyncTaskExecutor());
        return applicationEventMulticaster;
    }
}

Now all the listeners will run asynchronously, no blocking/waiting.

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

The complete flow:
==================

Config:
-------
@Configuration
@ComponentScan("com.savan")
public class AppConfig {

    @Bean("applicationEventMulticaster")
    public ApplicationEventMulticaster makingAsync() {
        SimpleApplicationEventMulticaster applicationEventMulticaster = new SimpleApplicationEventMulticaster();
        applicationEventMulticaster.setTaskExecutor(new SimpleAsyncTaskExecutor());
        return applicationEventMulticaster;
    }

}

Publisher:
----------
@Component
public class Gpay {

    @Autowired
    private ApplicationEventPublisher eventPublisher;

    public void sendMoney(String name, double amount, boolean condition) {
        try {
            if (condition) throw new RuntimeException("Transaction failed... ");
            System.out.println("Hi "+name);
            System.out.println("Sending amount "+amount+" is successful!");
        } catch (Exception e) {
            eventPublisher.publishEvent(new TransactionFailureEvent(name, amount));
            e.printStackTrace();
        }
    }
}

Main:
-----
public class Main {
    public static void main(String[] args) {
        AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(AppConfig.class);
        context.start();

        Gpay bean = context.getBean("gpay", Gpay.class);
        bean.sendMoney("Savan", 5000, false);
        bean.sendMoney("Savan", 5000, true);

        context.stop();
        context.close();
    }
}

Event:
------
public class TransactionFailureEvent {

    private String name;
    private double amount;

    public TransactionFailureEvent(String name, double amount) {
        this.name = name;
        this.amount = amount;
    }

    public String getName() {
        return name;
    }

    public double getAmount() {
        return amount;
    }
}

Listener:
---------
@Component
public class ApplicationContextListeners {

    @EventListener
    public void onContextRefreshedEvent(ContextRefreshedEvent event) {
        System.out.println("application initialized or refreshed... ");
        System.out.println(event);
    }

    @EventListener
    public void onContextStartedEvent(ContextStartedEvent event) {
        System.out.println("application initialized with start()... ");
        System.out.println(event);
    }

    @EventListener
    public void onContextStoppedEvent(ContextStoppedEvent event) {
        System.out.println("application stopped with stop()... ");
        System.out.println(event);
    }

    @EventListener
    public void onContextClosedEvent(ContextClosedEvent event) {
        System.out.println("application closed with close()... ");
        System.out.println(event);
    }
}

@Component
public class SendEmailListener {

    @EventListener
    public void emailListener(TransactionFailureEvent event) {
        System.out.println("SendEmailListener ->  inside emailListener() starting... ");
        try {
            Thread.sleep(3000);
            System.out.println("Sending an email with body \n"
                    + "Hi "+event.getName()+", transaction failed for the amount: "+event.getAmount());
        } catch (Exception e) {
            e.printStackTrace();
        }
        System.out.println("SendEmailListener ->  inside emailListener() ending... ");
    }
}

@Component
public class SendSMSListener {
    
    @EventListener
    public void smsListener(TransactionFailureEvent event) {
        System.out.println("Sending an sms with body \n"
            + "Hi "+event.getName()+", transaction failed for the amount: "+event.getAmount());
    }
}

o/p on main() run:
==================
Hi Savan
application initialized or refreshed... 
application initialized with start()... 
Sending amount 5000.0 is successful!
java.lang.RuntimeException: Transaction failed... 
	at com.savan.spring.event.publisher.Gpay.sendMoney(Gpay.java:16)
	at com.savan.spring.event.Main.main(Main.java:15)
SendEmailListener ->  inside emailListener() starting... 
Sending an sms with body 
Hi Savan, transaction failed for the amount: 5000.0
application stopped with stop()... 
application closed with close()... 
org.springframework.context.event.ContextClosedEvent[source=org.springframework.context.annotation.AnnotationConfigApplicationContext@246b179d, started on Wed Nov 26 01:18:07 IST 2025]
org.springframework.context.event.ContextStartedEvent[source=org.springframework.context.annotation.AnnotationConfigApplicationContext@246b179d, started on Wed Nov 26 01:18:07 IST 2025]
org.springframework.context.event.ContextStoppedEvent[source=org.springframework.context.annotation.AnnotationConfigApplicationContext@246b179d, started on Wed Nov 26 01:18:07 IST 2025]
org.springframework.context.event.ContextRefreshedEvent[source=org.springframework.context.annotation.AnnotationConfigApplicationContext@246b179d, started on Wed Nov 26 01:18:07 IST 2025]
Sending an email with body 
Hi Savan, transaction failed for the amount: 5000.0
SendEmailListener ->  inside emailListener() ending... 

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

With @EnableAsync and @Async:
=============================

Annotate your config class with @EnableAsync:
---------------------------------------------
@EnableAsync
@Configuration
@ComponentScan("com.savan")
public class AppConfig {

}

Annotate your listeners with @Async:
------------------------------------
@Component
public class SendEmailListener {

    @Async
    @EventListener
    public void emailListener(TransactionFailureEvent event) {
        System.out.println("SendEmailListener ->  inside emailListener() starting... ");
        try {
            Thread.sleep(3000);
            System.out.println("Sending an email with body \n"
                    + "Hi "+event.getName()+", transaction failed for the amount: "+event.getAmount());
        } catch (Exception e) {
            e.printStackTrace();
        }
        System.out.println("SendEmailListener ->  inside emailListener() ending... ");
    }
}

Note: @EnableAsync and @Async makes the listeners to run asynchronously, no blocking/waiting.

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

pom.xml:
========
pom.xml:
========
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <groupId>com.savan.spring.event</groupId>
    <artifactId>spring-event</artifactId>
    <version>1.0-SNAPSHOT</version>

    <properties>
        <maven.compiler.source>21</maven.compiler.source>
        <maven.compiler.target>21</maven.compiler.target>
        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
    </properties>

    <dependencies>
        <dependency>
            <groupId>org.springframework</groupId>
            <artifactId>spring-context</artifactId>
            <version>6.1.3</version>
        </dependency>
    </dependencies>

</project>


